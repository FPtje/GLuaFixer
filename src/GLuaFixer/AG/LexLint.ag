optpragmas
{
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# LANGUAGE CPP #-}
}

module {GLuaFixer.AG.LexLint}
{
    lintWarnings,
    fixedLexPositions
}
{}

imports
{
import Data.List
import GLua.TokenTypes
import GLua.AG.Token
import GLua.Position
import GLuaFixer.LintMessage
import GLuaFixer.LintSettings
}
include "../../GLua/AG/Token.ag"


{

----------------------------------------
--  C-style / Lua-style syntax inconsistencies
----------------------------------------
-- For detecting the usage of Lua/C syntax inconsistently
data SyntaxUsed = SyntaxUsed { luaUsed :: Bool, cUsed :: Bool } deriving (Show)

instance Semigroup SyntaxUsed where
    (SyntaxUsed l1 c1) <> (SyntaxUsed l2 c2) = SyntaxUsed (l1 || l2) (c1 || c2)

-- Monoid instance
instance Monoid SyntaxUsed where
    mempty = SyntaxUsed False False

mTokenWarning :: Region -> Issue -> FilePath -> LintMessage
mTokenWarning pos issue = LintMessage LintWarning pos issue

isSingleChar :: String -> Bool
isSingleChar [] = True
isSingleChar ('\\' : xs) = length xs == 1
isSingleChar (_ : []) = True
isSingleChar _ = False

-- Locate the exact position of trailing whitespace
locateTrailingWhitespace :: LineColPos -> String -> (LineColPos, String)
locateTrailingWhitespace pos (' ' : xs) = (pos, xs)
locateTrailingWhitespace pos ('\t' : xs) = (pos, xs)
locateTrailingWhitespace pos (x : xs) = locateTrailingWhitespace (customAdvanceChr pos x) xs
locateTrailingWhitespace pos [] = (pos, "")

-- Locate the start of a line's indentation in a string of whitespace
indentationStart :: LineColPos -> String -> LineColPos
indentationStart pos = go pos pos
  where
    go :: LineColPos -> LineColPos -> String -> LineColPos
    go _ cur ('\n' : xs) = let next = customAdvanceChr cur '\n' in go next next xs
    go found cur (x : xs) = go found (customAdvanceChr cur x) xs
    go found _ [] = found

endOfTrailingWhitespace :: (LineColPos, String) -> LineColPos
endOfTrailingWhitespace (pos, ('\n' : _)) = pos
endOfTrailingWhitespace (pos, (x : xs)) = endOfTrailingWhitespace (customAdvanceChr pos x, xs)
endOfTrailingWhitespace (pos, []) = pos


}
----------------------------------------
--  Attributes
----------------------------------------
attr MTokenList MToken Token
    syn copy :: self
    inh config :: LintSettings

    syn warnings use {++} {[]} :: {[FilePath -> LintMessage]}

    chn lineCommentSyntax :: SyntaxUsed
    chn multilineCommentSyntax :: SyntaxUsed
    chn notSyntax :: SyntaxUsed
    chn andSyntax :: SyntaxUsed
    chn orSyntax  :: SyntaxUsed
    chn neqSyntax :: SyntaxUsed
    chn strSyntax :: SyntaxUsed
    chn indentation :: SyntaxUsed -- Let's imagine Lua syntax = spaces, C syntax = tabs

    chn nextTokenPos :: LineColPos

attr Token
    syn tokenWarnings use {++} {[]} :: {[Issue]}
    syn customWarnings use {++} {[]} :: {[FilePath -> LintMessage]} -- Warnings where the position is modified

---------------------------------------
--  Semantics
---------------------------------------
sem MTokenList
    | Cons
    | Nil


sem MToken
    | MToken
        loc.mpos = Region @lhs.nextTokenPos (customAdvanceToken @lhs.nextTokenPos @mtok.copy)
        -- Note: the const is here to avoid a "defined but not used" warning in the generated hs
        -- file.
        loc.copy = MToken (const @loc.mpos @mpos) @mtok.copy

        -- Warnings from tokens
        lhs.warnings = @mtok.customWarnings ++ map (mTokenWarning @loc.mpos) @mtok.tokenWarnings

sem Token
    | Whitespace
        loc.curTokenPos = @lhs.nextTokenPos
        loc.nextTokenPos = customAdvanceStr @loc.curTokenPos @space
        loc.indentation = if @loc.inconsistent then mempty else @loc.whitespaceUsed
        loc.whitespaceUsed = @lhs.indentation <> SyntaxUsed (isInfixOf "\n " @space) (isInfixOf "\n\t" @space)
        loc.inconsistent = luaUsed @loc.whitespaceUsed && cUsed @loc.whitespaceUsed

        -- Start and end of trailing whitespace
        loc.whitespaceStart = locateTrailingWhitespace @loc.curTokenPos @space
        loc.whitespaceEnd = endOfTrailingWhitespace @loc.whitespaceStart

        -- Start and end of indentation at the start of a line
        loc.indentationRg = Region (indentationStart @loc.curTokenPos @space) @loc.nextTokenPos

        +customWarnings = if not (lint_trailingWhitespace @lhs.config) || (not (isInfixOf " \n" @space) && not (isInfixOf "\t\n" @space)) then id else (:) $ mTokenWarning (Region (fst @loc.whitespaceStart) @loc.whitespaceEnd) TrailingWhitespace

        +customWarnings = if not (lint_whitespaceStyle @lhs.config) || not @loc.inconsistent then id else
                            (:) $ mTokenWarning @loc.indentationRg InconsistentTabsSpaces

    | DashComment
        lhs.nextTokenPos = customAdvanceToken @lhs.nextTokenPos @loc.copy
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . cUsed $ @lhs.lineCommentSyntax)
        loc.lineCommentSyntax = SyntaxUsed @loc.consistent False -- When inconsistent, reset consistency check
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "--" "//"

    | SlashComment
        lhs.nextTokenPos = customAdvanceToken @lhs.nextTokenPos @loc.copy
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . luaUsed $ @lhs.lineCommentSyntax)
        loc.lineCommentSyntax = SyntaxUsed False @loc.consistent
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "//" "--"


    | DashBlockComment
        loc.str = showString "--[" . showString (replicate @depth '-') . showChar '[' . showString @comment . showChar ']' . showString (replicate @depth '-') . showChar ']' $ ""
        lhs.nextTokenPos = customAdvanceStr @lhs.nextTokenPos @loc.str
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . cUsed $ @lhs.multilineCommentSyntax)
        loc.multilineCommentSyntax = SyntaxUsed @loc.consistent False
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "--[[ ]]" "/* */"

    | SlashBlockComment
        loc.str = showString "/*" . showString @comment . showString "*/" $ ""
        lhs.nextTokenPos = customAdvanceStr @lhs.nextTokenPos @loc.str
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . luaUsed $ @lhs.multilineCommentSyntax)
        loc.multilineCommentSyntax = SyntaxUsed False @loc.consistent
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "/* */" "--[[ ]]"

    | Semicolon TNumber TTrue TFalse Nil VarArg Plus Minus Multiply Divide Modulus Power TEq TNEq TCNEq TLEQ TGEQ TLT TGT Equals Concatenate Colon Dot Comma Hash Not CNot And CAnd Or COr Function Local If Then Elseif Else For In Do While Until Repeat Continue Break Return End LRound RRound LCurly RCurly LSquare RSquare Identifier
        lhs.nextTokenPos = customAdvanceToken @lhs.nextTokenPos @loc.copy

    | DQString
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . cUsed $ @lhs.strSyntax)
        loc.strSyntax = SyntaxUsed @loc.consistent False
        -- Apply custom advancement of the string, but also have the advancement take the quotes into account
        lhs.nextTokenPos = customAdvanceStr @lhs.nextTokenPos $ "\"" <> @str <> "\""
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "double quoted strings" "single quoted strings"

    | SQString
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . luaUsed $ @lhs.strSyntax) || isSingleChar @str -- Allow single character ' ' strings
        loc.strSyntax = SyntaxUsed False (@loc.consistent && not (isSingleChar @str))
        -- Apply custom advancement of the string, but also have the advancement take the quotes into account
        lhs.nextTokenPos = customAdvanceStr @lhs.nextTokenPos $ "'" <> @str <> "'"
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "single quoted strings" "double quoted strings"

    | MLString
        lhs.nextTokenPos = customAdvanceStr @lhs.nextTokenPos @str

    | Not
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . cUsed $ @lhs.notSyntax)
        loc.notSyntax = SyntaxUsed @loc.consistent False
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "not" "!"

    | CNot
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . luaUsed $ @lhs.notSyntax)
        loc.notSyntax = SyntaxUsed False @loc.consistent
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "!" "not"

    | And
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . cUsed $ @lhs.andSyntax)
        loc.andSyntax = SyntaxUsed @loc.consistent False
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "and" "&&"

    | CAnd
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . luaUsed $ @lhs.andSyntax)
        loc.andSyntax = SyntaxUsed False @loc.consistent
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "&&" "and"

    | Or
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . cUsed $ @lhs.orSyntax)
        loc.orSyntax = SyntaxUsed @loc.consistent False
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "or" "||"

    | COr
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . luaUsed $ @lhs.orSyntax)
        loc.orSyntax = SyntaxUsed False @loc.consistent
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "||" "or"

    | TNEq
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . cUsed $ @lhs.neqSyntax)
        loc.neqSyntax = SyntaxUsed @loc.consistent False
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "~=" "!="

    | TCNEq
        loc.consistent = (not . lint_syntaxInconsistencies $ @lhs.config) || (not . luaUsed $ @lhs.neqSyntax)
        loc.neqSyntax = SyntaxUsed False @loc.consistent
        +tokenWarnings = if @loc.consistent then id else
                            (:) $ SyntaxInconsistency "!=" "~="

    | Label
        lhs.nextTokenPos = customAdvanceStr @lhs.nextTokenPos (show @loc.copy)

{


inh_MTokenList :: LintSettings -> Inh_MTokenList
inh_MTokenList conf =
                 Inh_MTokenList {
                    config_Inh_MTokenList                   = conf,
                    andSyntax_Inh_MTokenList                = mempty,
                    indentation_Inh_MTokenList              = mempty,
                    lineCommentSyntax_Inh_MTokenList        = mempty,
                    multilineCommentSyntax_Inh_MTokenList   = mempty,
                    neqSyntax_Inh_MTokenList                = mempty,
                    notSyntax_Inh_MTokenList                = mempty,
                    orSyntax_Inh_MTokenList                 = mempty,
                    strSyntax_Inh_MTokenList                = mempty,
                    nextTokenPos_Inh_MTokenList             = LineColPos 0 0 0
                 }

lintWarnings        :: LintSettings -> [MToken] -> [String -> LintMessage]
lintWarnings conf p = warnings_Syn_MTokenList (wrap_MTokenList (sem_MTokenList p) (inh_MTokenList conf))

-- Necessary because the parser walks over tabs as though they are 8 spaces.
fixedLexPositions   :: [MToken] -> [MToken]
fixedLexPositions p = copy_Syn_MTokenList (wrap_MTokenList (sem_MTokenList p) (inh_MTokenList defaultLintSettings))
}
